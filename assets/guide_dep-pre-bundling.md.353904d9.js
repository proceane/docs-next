import{o as e,c as o,d}from"./app.b84b895a.js";const n='{"title":"Pre-bundling 된 디펜던시","description":"","frontmatter":{"title":"Pre-bundling 된 디펜던시"},"headers":[{"level":2,"title":"왜 이런 메시지가 나타나나요?","slug":"the-why"},{"level":2,"title":"자동으로 디펜던시 탐색하기","slug":"automatic-dependency-discovery"},{"level":2,"title":"모노리포 디펜던시","slug":"monorepos-and-linked-dependencies"},{"level":2,"title":"디펜던시 탐색 과정 커스터마이즈하기","slug":"customizing-the-behavior"},{"level":2,"title":"캐싱","slug":"caching"},{"level":3,"title":"파일 시스템 캐시","slug":"file-system-cache"},{"level":3,"title":"브라우저 캐시","slug":"browser-cache"}],"relativePath":"guide/dep-pre-bundling.md","lastUpdated":1625605013368}',a={},c=d('<h1 id="dependency-pre-building"><a class="header-anchor" href="#dependency-pre-building" aria-hidden="true">#</a>Pre-bundling 된 디펜던시</h1><p>맨 처음 <code>vite</code> 명령을 실행했을 때, 다음 메시지를 마주했을 것입니다.</p><div class="language-"><pre><code>Optimizable dependencies detected:\nreact, react-dom\nPre-bundling them to speed up dev server page load...\n(this will be run only when your dependencies have changed)\n</code></pre></div><h2 id="the-why"><a class="header-anchor" href="#the-why" aria-hidden="true">#</a>왜 이런 메시지가 나타나나요?</h2><p>이러한 메시지가 나타나는 이유는 Vite의 &quot;Pre-bundling&quot; 기능으로 인한 것인데, 이를 사용하는 목적은 다음과 같습니다.</p><ol><li><p><strong>CommonJS 그리고 UMD 모듈을 ESM으로 가져오기:</strong> 개발 시, Vite의 개발 서버는 모든 코드를 네이티브 ESM으로 가져오게 됩니다. 따라서, vite는 반드시 모든 CommonJS 및 UMD 파일을 ESM으로 불러올 수 있도록 변환 작업을 진행해줘야 합니다.</p><p>vite는 조금 영리하게 ESM 파일로 변환을 진행하는데, 가령 CommonJS 디펜던시를 변환해주는 경우 아래와 같이 이름을 지정해 CommonJS 형태의 모듈을 Import 할 수도 있습니다.</p><div class="language-js"><pre><code><span class="token comment">// 아래 코드는 정상적으로 동작합니다.</span>\n<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span>\n</code></pre></div></li><li><p><strong>퍼포먼스:</strong> vite는 여러 디펜던시가 존재하는 ESM 모듈을 하나의 모듈로 변환하여 페이지 로드에 대한 퍼포먼스를 향상시킵니다.</p><p>600개의 모듈을 갖고 있는 <a href="https://unpkg.com/browse/lodash-es/" target="_blank" rel="noopener noreferrer"><code>lodash-es</code></a>와 같이 매우 많은 모듈을 Import하는 디펜던시의 경우, 그 수만큼 HTTP 요청을 전송하게 됩니다(<code>import { debounce } from &#39;loash-es&#39;</code>를 한다고 해도 말이죠). 서버가 이 요청들을 모두 정상적으로 처리한다고 해도, 브라우저 자체에서 이러한 네트워크 요청에 대한 오버헤드가 존재하기에 페이지 로드 퍼포먼스는 떨어질 수 밖에 없습니다. 즉, <code>lodash-es</code> 모듈을 Import하게 된다면... 600개의 HTTP 요청을 전송하게 되는 것이죠.</p><p>만약 <code>lodash-es</code> 모듈을 하나의 모듈로 번들링하게 된다면 어떻게 될까요? 브라우저는 단지 하나의 HTTP 요청만을 전송하게 됩니다.</p></li></ol><h2 id="automatic-dependency-discovery"><a class="header-anchor" href="#automatic-dependency-discovery" aria-hidden="true">#</a>자동으로 디펜던시 탐색하기</h2><p>만약 디펜던시가 캐시되지 않았다면 어떻게 될까요? vite는 프로젝트 내 모든 소스 코드를 탐색하여 디펜던시를 찾아낸 뒤, Pre-bundling을 이용해 Import 합니다(<code>node_modules</code>에서 디펜던시를 가져오듯이 말이죠). 물론, 이 Pre-bundling 과정은 <code>esbuild</code>를 이용하기에 보통 매우 빠른 속도로 진행됩니다.</p><p>서버가 이미 시작된 이후에 캐시되지 않은 새로운 디펜던시가 추가되는 경우라면, vite는 디펜던시 번들링 과정을 재시작하고 이후 해당 페이지를 다시 불러오게 됩니다.</p><h2 id="monorepos-and-linked-dependencies"><a class="header-anchor" href="#monorepos-and-linked-dependencies" aria-hidden="true">#</a>모노리포 디펜던시</h2><p>모노리포 프로젝트의 경우 디펜던시는 동일한 하나의 리포지토리에 존재할 수 있습니다*. vite는 이 역시 자동으로 연결된 디펜던시를 탐색하여 소스 코드로 가져오지만, 이를 하나의 번들로 묶지는 않습니다. 그저 연결된 디펜던시를 분석할 뿐이죠. (* 모노리포는 두 개 이상의 리포지토리를 가지는 리포지토리입니다. 서로 관련된 리포지토리에 중복된 디펜던시가 많은 경우, 이를 하나로 통합하여 관리할 수 있다는 장점이 있습니다. 자세한 사항은 <a href="https://classic.yarnpkg.com/en/docs/workspaces/" target="_blank" rel="noopener noreferrer">Yarn workspaces</a>를 참고해주세요.)</p><h2 id="customizing-the-behavior"><a class="header-anchor" href="#customizing-the-behavior" aria-hidden="true">#</a>디펜던시 탐색 과정 커스터마이즈하기</h2><p>기본적으로 Vite의 Pre-bundling 디펜던시 탐색은 휴리스틱(Heuristics) 기반으로 이루어집니다. 물론 모든 상황에서 적절하게 동작할 것이라는 보장은 없죠. 만약 특정 디펜던시를 포함시키거나 포함시키지 않도록 설정하고자 한다면 <a href="/config/#dep-optimization-options"><code>optimizeDeps</code> 옵션</a>을 이용해주세요.</p><p>이 옵션은 일반적으로 소스 코드에서 바로 가져올 수 없는 파일에 대해 <code>optimizeDeps.include</code> 또는 <code>optimizeDeps.exclude</code>에 명시하는 방식으로 사용합니다. 플러그인을 통해 생성된 어떤 파일을 명시적으로 Import 하고자 하는 경우와 같이 말이죠. 다시말해 vite는 첫 번째 스캐닝 시 모든 디펜던시를 스캔하지 않으며, 오로지 브라우저가 요청했을 때에만 해당 디펜던시를 변환해 가져오는 방식으로 동작합닌다. 물론 서버가 이미 실행된 이후에도 말이죠.</p><p><code>include</code>나 <code>exclude</code>를 사용하는 예시를 들어 볼까요? 만약 디펜던시가 매우 크거나, 많은 모듈을 포함하고 있거나, CommonJS 포맷으로 되어있는 경우 이 디펜던시들을 Pre-bundling 과정에 포함시킬 수 있도록 <code>include</code> 옵션에 명시해야 합니다. 만약 디펜던시가 작거나, 이미 ESM 스타일로 작성된 경우라면 굳이 Pre-bundling 과정에 포함시킬 필요가 없으니 <code>exclude</code> 옵션에 명시해 브라우저에서 바로 불러올 수 있도록 설정할 수도 있습니다.</p><h2 id="caching"><a class="header-anchor" href="#caching" aria-hidden="true">#</a>캐싱</h2><h3 id="file-system-cache"><a class="header-anchor" href="#file-system-cache" aria-hidden="true">#</a>파일 시스템 캐시</h3><p>Vite는 Pre-bundling 된 디펜던시를 <code>node_modules/.vite</code> 디렉터리 내에 캐시하고 있습니다. 다만 이를 다시 번들링하는 경우가 있는데, 다음과 같습니다.</p><ul><li><code>package.json</code> 내 <code>dependencies</code> 리스트가 변경되었을 때</li><li><code>package-lock.json</code>, <code>yarn.lock</code> 또는 <code>pnpm-lock.yaml</code> 파일과 같은 패키지 매니저의 Lock 파일이 변경되었을 때</li><li><code>vite.config.js</code>와 관련되어 있는 필드가 변경되었을 때</li></ul><p>위의 변경 사항이 발생된 경우 Pre-bundling 과정을 다시 시작하게 됩니다.</p><p>만약 강제로 디펜던시를 다시 번들링해야 하는 경우, 개발 서버를 <code>--force</code> 옵션과 함께 시작해주세요. 또는 그냥 <code>node_modules/.vite</code> 디렉터리를 삭제해줘도 됩니다.</p><h3 id="browser-cache"><a class="header-anchor" href="#browser-cache" aria-hidden="true">#</a>브라우저 캐시</h3><p>HTTP 헤더를 <code>max-age=31536000,immutable</code>과 같이 디펜던시가 반드시 캐시되도록 설정한 경우*, 개발 시 페이지를 다시 불러올 때의 퍼포먼스를 향상시킬 수 있습니다. 한 번 캐시된 디펜던시는 다시 서버에 요청하지 않기 때문이죠. 물론 캐시된 디펜던시와 다른 버전이 설치된 경우, 기존 버전은 자동으로 무효화됩니다. 물론 아래의 과정을 통해 버전 변경 없이 직접 디펜던시를 수정(디버그)할 수도 있습니다. (* Pre-bundling 된 디펜던시의 경우 이 헤더가 추가됩니다.)</p><ol><li>브라우저의 개발자 도구를 이용해 캐시를 사용하지 않도록 설정합니다.</li><li>디펜던시를 다시 번들링하는 <code>--force</code> 옵션과 함께 Vite의 개발 서버를 재시작합니다.</li><li>페이지를 다시 로드합니다.</li></ol>',24);a.render=function(d,n,a,i,r,t){return e(),o("div",null,[c])};export default a;export{n as __pageData};
