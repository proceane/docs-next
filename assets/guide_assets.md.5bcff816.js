import{o as s,c as a,d as n}from"./app.b84b895a.js";const e='{"title":"에셋 가져오기","description":"","frontmatter":{"title":"에셋 가져오기"},"headers":[{"level":2,"title":"URL을 통해 에셋 Import 하기","slug":"importing-asset-as-url"},{"level":3,"title":"접미사를 이용해 URL로 에셋 가져오기","slug":"explicit-url-imports"},{"level":3,"title":"문자열 형태로 에셋 가져오기","slug":"importing-asset-as-string"},{"level":3,"title":"스크립트를 Worker로 가져오기","slug":"importing-script-as-a-worker"},{"level":2,"title":"public 디렉터리","slug":"the-public-directory"},{"level":2,"title":"new URL(url, import.meta.url)","slug":"new-url-url-import-meta-url"}],"relativePath":"guide/assets.md","lastUpdated":1625605013368}',t={},o=n('<h1 id="static-asset-handling"><a class="header-anchor" href="#static-asset-handling" aria-hidden="true">#</a>에셋 가져오기</h1><p>다음 두 개의 주제와 관련있는 섹션입니다.</p><ul><li><a href="./build.html#public-base-path">Public Base Path</a></li><li><a href="/config/#assetsinclude"><code>assetsInclude</code> config option</a></li></ul><h2 id="importing-asset-as-url"><a class="header-anchor" href="#importing-asset-as-url" aria-hidden="true">#</a>URL을 통해 에셋 Import 하기</h2><p>정적 에셋을 Import하게 되면 에셋에 접근할 수 있는 URL이 반환됩니다.</p><div class="language-js"><pre><code><span class="token keyword">import</span> imgUrl <span class="token keyword">from</span> <span class="token string">&#39;./img.png&#39;</span>\ndocument<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;hero-img&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> imgUrl\n</code></pre></div><p>예를 들어, <code>imgUrl</code> 객체는 개발 시 <code>/img.png</code> 값으로 할당되겠으나, 실제 배포 버전에서는 <code>/assets/img.2d8efhg.png</code>와 같은 값*이 할당됩니다. (* 여기서 <code>2d8efhg</code>는 해시 값을 의미합니다.)</p><p>Webpack의 <code>file-loader</code>와 비슷한데, 하나 차이점이 있다면 Vite는 절대 경로와 상대 경로 둘 다 사용할 수 있습니다.</p><ul><li><p><code>url()</code>로 참조되는 CSS의 경우 동일한 방식으로 동작합니다.</p></li><li><p>만약 Vue 플러그인을 사용한다면, <a href="https://v3.vuejs.org/guide/single-file-component.html" target="_blank" rel="noopener noreferrer">Vue SFC</a> 에셋의 경우 자동으로 변환되어 Import 됩니다.</p></li><li><p>일반적인 이미지, 미디어, 폰트 파일 타입은 자동으로 에셋 목록에 포함됩니다. 물론 <a href="/config/#assetsinclude"><code>assetsInclude</code> 옵션</a>을 이용해 더 많은 파일 타입을 포함하도록 할 수 있습니다.</p></li><li><p>참조된 에셋은 빌드 에셋 그래프의 일부 요소로 포함되며, 파일 이름이 해싱되거나 최적화를 위해 플러그인으로 처리될 수 있습니다.</p></li><li><p><a href="/config/#assetsinlinelimit"><code>assetsInlineLimimt</code> 옵션</a>의 값보다 작은 에셋 파일의 경우, Base64 포맷의 데이터 URL* 문자열로 가져옵니다. (* <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs" target="_blank" rel="noopener noreferrer">데이터 URL MDN doc</a>)</p></li></ul><h3 id="explicit-url-imports"><a class="header-anchor" href="#explicit-url-imports" aria-hidden="true">#</a>접미사를 이용해 URL로 에셋 가져오기</h3><p><code>assetsInclude</code> 옵션 또는 URL로 가져오도록 Vite 내부적으로 설정된 리스트에 포함되지 않은 에셋의 경우에도 URL 포맷으로 에셋을 가져오도록 지정할 수 있습니다. <code>?url</code> 접미사(Suffix)를 붙여 에셋을 가져오면 되는데, 예를 하나 들어보자면 다음과 같습니다.</p><div class="language-js"><pre><code><span class="token keyword">import</span> workletURL <span class="token keyword">from</span> <span class="token string">&#39;extra-scalloped-border/worklet.js?url&#39;</span>\n<span class="token constant">CSS</span><span class="token punctuation">.</span>paintWorklet<span class="token punctuation">.</span><span class="token function">addModule</span><span class="token punctuation">(</span>workletURL<span class="token punctuation">)</span>\n</code></pre></div><h3 id="importing-asset-as-string"><a class="header-anchor" href="#importing-asset-as-string" aria-hidden="true">#</a>문자열 형태로 에셋 가져오기</h3><p><code>?raw</code> 접미사를 붙여 Import하는 에셋은 문자열 형태로 가져와지게 됩니다.</p><div class="language-js"><pre><code><span class="token keyword">import</span> shaderString <span class="token keyword">from</span> <span class="token string">&#39;./shader.glsl?raw&#39;</span>\n</code></pre></div><h3 id="importing-script-as-a-worker"><a class="header-anchor" href="#importing-script-as-a-worker" aria-hidden="true">#</a>스크립트를 Worker로 가져오기</h3><p>스크립트는 웹 워커로 가져올 수 있는데, 이 때는 <code>?worker</code> 접미사를 이용합니다.</p><div class="language-js"><pre><code><span class="token comment">// 배포 시에는 청크로 분리됩니다.</span>\n<span class="token keyword">import</span> Worker <span class="token keyword">from</span> <span class="token string">&#39;./shader.js?worker&#39;</span>\n<span class="token keyword">const</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// sharedworker</span>\n<span class="token keyword">import</span> SharedWorker <span class="token keyword">from</span> <span class="token string">&#39;./shader.js?sharedworker&#39;</span>\n<span class="token keyword">const</span> sharedWorker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SharedWorker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// `inline` 접미사는 Base64 포맷의 문자열로 에셋을 가져옵니다.</span>\n<span class="token keyword">import</span> InlineWorker <span class="token keyword">from</span> <span class="token string">&#39;./shader.js?worker&amp;inline&#39;</span>\n</code></pre></div><p>좀 더 자세한 사항은 <a href="./features.html#web-workers">웹 워커 섹션</a>을 참고해주세요.</p><h2 id="the-public-directory"><a class="header-anchor" href="#the-public-directory" aria-hidden="true">#</a><code>public</code>디렉터리</h2><p>다음 에셋의 경우</p><ul><li><code>robots.txt</code>와 같이 소스 코드에서 참조되지 않는 에셋</li><li>해싱 없이 항상 같은 이름을 갖는 에셋</li><li>또는 URL을 얻기 위해 굳이 Import 할 필요 없는 에셋</li></ul><p><code>public</code> 디렉터리 아래에 에셋을 위치시키세요. 이 곳에 위치한 에셋은 개발 시에 <code>/</code> 경로에, 배포 시에는 <code>dist</code> 디렉터리에 위치하게 됩니다.</p><p>만약 <code>&lt;root&gt;/public</code> 디렉터리가 아닌 다른 디렉터리를 사용하고자 하는 경우, <a href="/config/#publicdir"><code>publicDir</code> 옵션</a>을 이용할 수 있습니다.</p><p>마지막으로, 다음의 사항을 유의해주세요.</p><ul><li><code>public</code> 디렉터리에 위치해 있는 에셋을 가져오고자 하는 경우, 항상 루트를 기준으로 하는 절대 경로로 가져와야만 합니다. ( <code>public/icon.png</code> 에셋은 소스 코드에서 <code>/icon.png</code>으로 접근이 가능합니다.)</li><li><code>public</code> 디렉터리에 위치한 에셋은 JavaScript 코드로 가져올 수 없습니다.</li></ul><h2 id="new-url-url-import-meta-url"><a class="header-anchor" href="#new-url-url-import-meta-url" aria-hidden="true">#</a>new URL(url, import.<wbr>meta.url)</h2><p>네이티브 ESM의 API 중 하나인 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.&lt;wbr/&gt;meta" target="_blank" rel="noopener noreferrer">import.<wbr>meta.url</a>은 현재 모듈의 URL을 보여주는 기능입니다. <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL" target="_blank" rel="noopener noreferrer">URL 생성자</a>와 함께 사용하면, 정적 에셋의 전제 URL을 확인할 수 있게 됩니다.</p><div class="language-js"><pre><code><span class="token keyword">const</span> imgUrl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">&#39;./img.png&#39;</span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span>\n\ndocument<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;hero-img&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> imgUrl\n</code></pre></div><p>위 코드는 네이티브 ESM을 지원하는 모던 브라우저에서 동작합니다. 물론, Vite는 위 동작을 자동으로 수행해주기에 따로 처리할 필요는 없습니다.</p><p>참고로 위 코드는 템플릿 리터럴을 이용해 동적으로 생성되는 URL에서도 동작합니다.</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">getImageUrl</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./dir/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.png</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>href\n<span class="token punctuation">}</span>\n</code></pre></div><p>배포 버전으로 빌드 시, Vite는 번들링 및 에셋 해싱 후에도 해당 에셋에 대한 URL을 올바르게 가리키기 위해 필요한 변환 작업을 수행합니다.</p><div class="warning custom-block"><p class="custom-block-title">SSR과 함께 사용하지 마세요!</p><p><code>import.<wbr>meta.url</code>은 브라우저와 Node.js 간 서로 다른 의미를 갖기 때문에, 이 패턴은 서버-사이드 렌더링(SSR)에 Vite를 사용하는 경우 동작하지 않습니다.</p></div>',36);t.render=function(n,e,t,p,r,c){return s(),a("div",null,[o])};export default t;export{e as __pageData};
